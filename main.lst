CCS PCH C Compiler, Version 5.008, 5967               02-mai-19 10:37

               Filename:   C:\Users\Jhow\Desktop\finalmente\main.lst

               ROM used:   1128 bytes (3%)
                           Largest free fragment is 31640
               RAM used:   12 (1%) at main() level
                           58 (3%) worst case
               Stack used: 6 locations
               Stack size: 31

*
0000:  GOTO   03DC
.................... #include <main.h> 
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
0004:  DATA 61,00
0006:  DATA 62,00
0008:  DATA 63,00
000A:  DATA 64,00
000C:  DATA 00,00
000E:  DATA 61,00
0010:  DATA 62,00
0012:  DATA 63,00
0014:  DATA 64,00
0016:  DATA 00,00
....................  
.................... #list 
....................  
.................... #device ADC=16 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................  
.................... #use delay(crystal=20000000) 
0018:  CLRF   FEA
001A:  MOVLW  39
001C:  MOVWF  FE9
001E:  MOVF   FEF,W
0020:  BZ    003C
0022:  MOVLW  06
0024:  MOVWF  01
0026:  CLRF   00
0028:  DECFSZ 00,F
002A:  BRA    0028
002C:  DECFSZ 01,F
002E:  BRA    0026
0030:  MOVLW  7B
0032:  MOVWF  00
0034:  DECFSZ 00,F
0036:  BRA    0034
0038:  DECFSZ FEF,F
003A:  BRA    0022
003C:  RETURN 0
....................  
....................  
.................... #include <processador.c> 
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #use rs232(uart1, baud = 9600) 
....................  
.................... //#include "estrutura.c" 
.................... //#include "processador.c" 
....................  
.................... #define x pin_d0 //COORD X 
.................... #define y pin_d1 //COORD Y 
.................... #define z pin_d2 //COORD Z 
.................... #define start pin_a1 //BUTTON START 
.................... #define stop pin_a2 //BUTTON STOP 
.................... #define ventosa pin_d5 //AC VENTOSA 
.................... #define sa_x pin_a4 //SENSOR AVANCADO X 
.................... #define sr_x pin_a3 //SENSOR RETORNADO X 
.................... #define sa_y pin_e0 //SENSOR AVANCADO Y 
.................... #define sr_y pin_a5 //SENSOR RETORNADO Y 
.................... #define sa_z pin_e2 //SENSOR AVANCADO Z 
.................... #define sr_z pin_e1 //SENSOR RETORNADO Z 
.................... #define buzzer pin_c1 //BUZZER 
....................  
.................... void set_ventosa(); 
.................... void get_ventosa(); 
....................  
.................... void process(char get_c, char set_c); 
.................... void process_all(char); 
....................  
....................  int set(int,int); 
....................  int get(int,int); 
.................... void reset(); 
.................... /*int etapa_START; 
.................... int etapa_STOP; 
.................... int a; 
.................... int b; 
.................... int c; 
.................... int d;  //##CODIGO ANTIGO 
....................  
.................... void inicial(); 
.................... void reset();*/ 
.................... //##BUZZERS 
....................  int b_V(int);//BUZZER 20MS 
....................  int b_Q(int);//BUZZER 40MS 
....................  int b_C(int);//BUZZER 100MS 
....................  void b_S(int s);//BUZZER 1000MS / 1 S 
.................... /*##ACOES 
.................... void get_xr_ya(); // PEGA X RETORNADO Y AVANÇADO 
.................... void get_xr_yr(); // PEGA X RETORNADO Y RETORNADO 
.................... void get_xa_yr(); // PEGA X AVANCADO Y RETORNADO 
.................... void get_xa_ya(); // PEGA X AVANCADO Y AVANCADO 
.................... //##set 
.................... void set_xr_ya(); // SETA X RETORNADO Y AVANCADO 
.................... void set_xr_yr(); // SETA X RETORNADO Y RETORNADO 
.................... void set_xa_yr(); // SETA X AVANCADO Y RETORNADO 
.................... void set_xa_ya(); // SETA X AVANCADO Y AVANCADO*/ 
....................    int i; 
....................  int gx; 
....................  int gy; 
....................  int sx; 
....................  int sy; 
.................... /* 
.................... # 
.................... ###~~MESA PNEUMATICA POS; 
.................... # 
.................... #     XR_YR    XA_YR 
.................... #       A        B 
.................... #      
.................... #     XR_YA    XA_YA 
.................... #       C        D 
.................... # 
.................... #EXEMPLO; A+B ~ C+D ## B A  
.................... #                      D C 
.................... */ 
....................  
.................... /* 
....................  
....................    A = 0 | 0 
....................    B = 1 | 0 
....................    C = 0 | 1 
....................    D = 1 | 1 
....................     
....................    D+A|C+D|B+C|D+B 
....................    01234567891011121314 
....................     
.................... */ 
....................  
.................... void process_all(int param[]) { 
*
0332:  CLRF   2D
0334:  CLRF   2E
.................... //1234567891011121314 
....................    int g =0; 
....................    int s =0; 
....................    int g_x; 
....................    int g_y; 
....................    int s_x; 
....................    int s_y; 
....................    for(g=0; g < 12; g+4) {  // 0 4 8 12  
0336:  CLRF   2D
0338:  MOVF   2D,W
033A:  SUBLW  0B
033C:  BNC   03D4
....................       for(s=2; s < 14; s+4) { // 2 6 10 14 
033E:  MOVLW  02
0340:  MOVWF  2E
0342:  MOVF   2E,W
0344:  SUBLW  0D
0346:  BNC   03D2
....................          if(param[g]!=2 || param[s]!=2) { 
0348:  CLRF   03
034A:  MOVF   2D,W
034C:  ADDWF  2B,W
034E:  MOVWF  FE9
0350:  MOVF   2C,W
0352:  ADDWFC 03,W
0354:  MOVWF  FEA
0356:  MOVF   FEF,W
0358:  SUBLW  02
035A:  BNZ   0370
035C:  CLRF   03
035E:  MOVF   2E,W
0360:  ADDWF  2B,W
0362:  MOVWF  FE9
0364:  MOVF   2C,W
0366:  ADDWFC 03,W
0368:  MOVWF  FEA
036A:  MOVF   FEF,W
036C:  SUBLW  02
036E:  BZ    03D0
....................          g_x = param[g]; 
0370:  CLRF   03
0372:  MOVF   2D,W
0374:  ADDWF  2B,W
0376:  MOVWF  FE9
0378:  MOVF   2C,W
037A:  ADDWFC 03,W
037C:  MOVWF  FEA
037E:  MOVFF  FEF,2F
....................          g_y = param[g+1]; 
0382:  MOVLW  01
0384:  ADDWF  2D,W
0386:  CLRF   03
0388:  ADDWF  2B,W
038A:  MOVWF  FE9
038C:  MOVF   2C,W
038E:  ADDWFC 03,W
0390:  MOVWF  FEA
0392:  MOVFF  FEF,30
....................          s_x = param[s]; 
0396:  CLRF   03
0398:  MOVF   2E,W
039A:  ADDWF  2B,W
039C:  MOVWF  FE9
039E:  MOVF   2C,W
03A0:  ADDWFC 03,W
03A2:  MOVWF  FEA
03A4:  MOVFF  FEF,31
....................          s_y = param[s+1]; 
03A8:  MOVLW  01
03AA:  ADDWF  2E,W
03AC:  CLRF   03
03AE:  ADDWF  2B,W
03B0:  MOVWF  FE9
03B2:  MOVF   2C,W
03B4:  ADDWFC 03,W
03B6:  MOVWF  FEA
03B8:  MOVFF  FEF,32
....................          get(g_x, g_y); 
03BC:  MOVFF  2F,33
03C0:  MOVFF  30,34
03C4:  BRA    011E
....................          set(s_x, s_y); 
03C6:  MOVFF  31,33
03CA:  MOVFF  32,34
03CE:  BRA    0246
....................          } 
03D0:  BRA    0342
....................       }       
03D2:  BRA    0338
....................    } 
....................    b_S(1); 
03D4:  MOVLW  01
03D6:  MOVWF  33
03D8:  BRA    030A
03DA:  RETURN 0
.................... } 
....................  
....................  
.................... void process(char get_c, char set_c) { 
....................     switch(get_c) { 
....................       case "a": 
....................       get(0,0); 
....................       case "b": 
....................       get(1,0); 
....................       case "c": 
....................       get(0,1); 
....................       case "d": 
....................       get(1,1); 
....................     } 
....................     switch(set_c) { 
....................       case "a": 
....................       set(0,0); 
....................       case "b": 
....................       set(1,0); 
....................       case "c": 
....................       set(0,1); 
....................       case "d": 
....................       set(1,1); 
....................     } 
.................... } 
....................  
....................  
.................... void get_ventosa(){ 
....................    b_V(1); 
*
00CE:  MOVLW  01
00D0:  MOVWF  37
00D2:  RCALL  003E
....................    output_high(z); 
00D4:  BCF    F95.2
00D6:  BSF    F8C.2
....................    while(input(sa_z)==0); 
00D8:  BSF    F96.2
00DA:  BTFSS  F84.2
00DC:  BRA    00D8
....................    delay_ms(200); 
00DE:  MOVLW  C8
00E0:  MOVWF  39
00E2:  RCALL  0018
....................    b_Q(2); 
00E4:  MOVLW  02
00E6:  MOVWF  37
00E8:  RCALL  0060
....................    output_high(ventosa); 
00EA:  BCF    F95.5
00EC:  BSF    F8C.5
....................    delay_ms(500); 
00EE:  MOVLW  02
00F0:  MOVWF  37
00F2:  MOVLW  FA
00F4:  MOVWF  39
00F6:  RCALL  0018
00F8:  DECFSZ 37,F
00FA:  BRA    00F2
....................    b_V(1); 
00FC:  MOVLW  01
00FE:  MOVWF  37
0100:  RCALL  003E
....................    output_low(z); 
0102:  BCF    F95.2
0104:  BCF    F8C.2
....................    while(input(sr_z)==0); 
0106:  BSF    F96.1
0108:  BTFSS  F84.1
010A:  BRA    0106
....................    delay_ms(500); 
010C:  MOVLW  02
010E:  MOVWF  37
0110:  MOVLW  FA
0112:  MOVWF  39
0114:  RCALL  0018
0116:  DECFSZ 37,F
0118:  BRA    0110
....................    reset(); 
011A:  RCALL  0082
011C:  RETURN 0
.................... } 
....................  
.................... void set_ventosa(){    
....................    b_V(1); 
*
01FE:  MOVLW  01
0200:  MOVWF  37
0202:  RCALL  003E
....................    output_high(z); 
0204:  BCF    F95.2
0206:  BSF    F8C.2
....................    while(input(sa_z)==0); 
0208:  BSF    F96.2
020A:  BTFSS  F84.2
020C:  BRA    0208
....................    delay_ms(200); 
020E:  MOVLW  C8
0210:  MOVWF  39
0212:  RCALL  0018
....................    b_Q(2); 
0214:  MOVLW  02
0216:  MOVWF  37
0218:  RCALL  0060
....................    output_low(ventosa); 
021A:  BCF    F95.5
021C:  BCF    F8C.5
....................    delay_ms(200); 
021E:  MOVLW  C8
0220:  MOVWF  39
0222:  RCALL  0018
....................    b_V(1); 
0224:  MOVLW  01
0226:  MOVWF  37
0228:  RCALL  003E
....................    output_low(z); 
022A:  BCF    F95.2
022C:  BCF    F8C.2
....................    while(input(sr_z)==0); 
022E:  BSF    F96.1
0230:  BTFSS  F84.1
0232:  BRA    022E
....................    delay_ms(500); 
0234:  MOVLW  02
0236:  MOVWF  37
0238:  MOVLW  FA
023A:  MOVWF  39
023C:  RCALL  0018
023E:  DECFSZ 37,F
0240:  BRA    0238
....................    reset(); 
0242:  RCALL  0082
0244:  RETURN 0
.................... } 
....................  
.................... int set(int s_x, int s_y){ 
0246:  MOVFF  33,35
024A:  MOVFF  34,36
....................     int sx = s_x; 
....................     int sy = s_y; 
....................    if(sx==1) {//CHECA SE X DEVE SER AVANÇADO 
024E:  DECFSZ 35,W
0250:  BRA    02B8
....................    b_V(1); 
0252:  MOVLW  01
0254:  MOVWF  37
0256:  RCALL  003E
....................       output_high(x);//AVANÇA X 
0258:  BCF    F95.0
025A:  BSF    F8C.0
....................       while(input(sa_x)==0); 
025C:  BSF    F92.4
025E:  BTFSS  F80.4
0260:  BRA    025C
....................       delay_ms(300); 
0262:  MOVLW  02
0264:  MOVWF  37
0266:  MOVLW  96
0268:  MOVWF  39
026A:  RCALL  0018
026C:  DECFSZ 37,F
026E:  BRA    0266
....................       if(sy==1) {//CHECA SE Y DEVE SER AVANÇADO 
0270:  DECFSZ 36,W
0272:  BRA    029C
....................          b_V(1); 
0274:  MOVLW  01
0276:  MOVWF  37
0278:  RCALL  003E
....................          output_high(y);//AVANÇA Y 
027A:  BCF    F95.1
027C:  BSF    F8C.1
....................          while(input(sa_y)==0); 
027E:  BSF    F96.0
0280:  BTFSS  F84.0
0282:  BRA    027E
....................          delay_ms(300); 
0284:  MOVLW  02
0286:  MOVWF  37
0288:  MOVLW  96
028A:  MOVWF  39
028C:  RCALL  0018
028E:  DECFSZ 37,F
0290:  BRA    0288
....................          set_ventosa();//SETA BLOCO 
0292:  RCALL  01FE
....................           sx = 2; 
0294:  MOVLW  02
0296:  MOVWF  35
....................           sy = 2; 
0298:  MOVWF  36
....................       }else if(sy==0) {//CHECA SE Y DEVE SER RETORNADO 
029A:  BRA    02B6
029C:  MOVF   36,F
029E:  BNZ   02B6
....................          delay_ms(300); 
02A0:  MOVLW  02
02A2:  MOVWF  37
02A4:  MOVLW  96
02A6:  MOVWF  39
02A8:  RCALL  0018
02AA:  DECFSZ 37,F
02AC:  BRA    02A4
....................          set_ventosa();//SETA BLOCO 
02AE:  RCALL  01FE
....................           sx = 2; 
02B0:  MOVLW  02
02B2:  MOVWF  35
....................           sy = 2; 
02B4:  MOVWF  36
....................       } 
....................    }else if(sx==0) {//CHECA SE X DEVE SER RETORNADO 
02B6:  BRA    0302
02B8:  MOVF   35,F
02BA:  BNZ   0302
....................       if(sy==1) {//CHECA SE Y DEVE SER AVANÇADO 
02BC:  DECFSZ 36,W
02BE:  BRA    02E8
....................       b_V(1); 
02C0:  MOVLW  01
02C2:  MOVWF  37
02C4:  RCALL  003E
....................          output_high(y);//AVANÇA Y 
02C6:  BCF    F95.1
02C8:  BSF    F8C.1
....................          while(input(sa_y)==0); 
02CA:  BSF    F96.0
02CC:  BTFSS  F84.0
02CE:  BRA    02CA
....................          delay_ms(300); 
02D0:  MOVLW  02
02D2:  MOVWF  37
02D4:  MOVLW  96
02D6:  MOVWF  39
02D8:  RCALL  0018
02DA:  DECFSZ 37,F
02DC:  BRA    02D4
....................          set_ventosa();//SETA BLOCO 
02DE:  RCALL  01FE
....................           sx = 2; 
02E0:  MOVLW  02
02E2:  MOVWF  35
....................           sy = 2; 
02E4:  MOVWF  36
....................       }else if(sy==0) {//CHECA SE Y DEVE SER RETORNADO 
02E6:  BRA    0302
02E8:  MOVF   36,F
02EA:  BNZ   0302
....................          delay_ms(300); 
02EC:  MOVLW  02
02EE:  MOVWF  37
02F0:  MOVLW  96
02F2:  MOVWF  39
02F4:  RCALL  0018
02F6:  DECFSZ 37,F
02F8:  BRA    02F0
....................          set_ventosa();//SETA BLOCO 
02FA:  RCALL  01FE
....................           sx = 2; 
02FC:  MOVLW  02
02FE:  MOVWF  35
....................           sy = 2; 
0300:  MOVWF  36
....................       } 
....................    } 
....................    return 0; 
0302:  MOVLW  00
0304:  MOVWF  01
0306:  GOTO   03D0 (RETURN)
.................... } 
....................  
.................... int get(int c_x, int c_y){ 
*
011E:  MOVFF  33,35
0122:  MOVFF  34,36
....................     int gx = c_x; 
....................     int gy = c_y; 
....................    if(gx == 1) {//CHECA SE X DEVE SER AVANÇADO  
0126:  DECFSZ 35,W
0128:  BRA    019E
....................    b_V(1); 
012A:  MOVLW  01
012C:  MOVWF  37
012E:  RCALL  003E
....................       output_high(x);//AVANÇA X 
0130:  BCF    F95.0
0132:  BSF    F8C.0
....................       delay_ms(300); 
0134:  MOVLW  02
0136:  MOVWF  37
0138:  MOVLW  96
013A:  MOVWF  39
013C:  RCALL  0018
013E:  DECFSZ 37,F
0140:  BRA    0138
....................       while(input(sa_x)==0); 
0142:  BSF    F92.4
0144:  BTFSS  F80.4
0146:  BRA    0142
....................          if(gy==1) {//CHECA SE Y DEVE SER AVANÇADO 
0148:  DECFSZ 36,W
014A:  BRA    0182
....................          b_V(1); 
014C:  MOVLW  01
014E:  MOVWF  37
0150:  RCALL  003E
....................           output_high(y);//AVANÇA Y 
0152:  BCF    F95.1
0154:  BSF    F8C.1
....................           delay_ms(300); 
0156:  MOVLW  02
0158:  MOVWF  37
015A:  MOVLW  96
015C:  MOVWF  39
015E:  RCALL  0018
0160:  DECFSZ 37,F
0162:  BRA    015A
....................           while(input(sa_y)==0); 
0164:  BSF    F96.0
0166:  BTFSS  F84.0
0168:  BRA    0164
....................           delay_ms(300); 
016A:  MOVLW  02
016C:  MOVWF  37
016E:  MOVLW  96
0170:  MOVWF  39
0172:  RCALL  0018
0174:  DECFSZ 37,F
0176:  BRA    016E
....................           get_ventosa();//PEGA O BLOCO 
0178:  RCALL  00CE
....................            gx = 2; 
017A:  MOVLW  02
017C:  MOVWF  35
....................           gy = 2; 
017E:  MOVWF  36
....................       }else if(gy==0) {//CHECA SE Y DEVE SER RETORNADO 
0180:  BRA    019C
0182:  MOVF   36,F
0184:  BNZ   019C
....................          delay_ms(300); 
0186:  MOVLW  02
0188:  MOVWF  37
018A:  MOVLW  96
018C:  MOVWF  39
018E:  RCALL  0018
0190:  DECFSZ 37,F
0192:  BRA    018A
....................           get_ventosa();//PEGA O BLOCO 
0194:  RCALL  00CE
....................            gx = 2; 
0196:  MOVLW  02
0198:  MOVWF  35
....................           gy = 2; 
019A:  MOVWF  36
....................       } 
....................    }else if(gx==0){//CHECA SE X DEVE SER RETORNADO 
019C:  BRA    01F6
019E:  MOVF   35,F
01A0:  BNZ   01F6
....................       if(gy==1) {//CHECA SE Y DEVE SER AVANÇADO 
01A2:  DECFSZ 36,W
01A4:  BRA    01DC
....................       b_V(1); 
01A6:  MOVLW  01
01A8:  MOVWF  37
01AA:  RCALL  003E
....................          output_high(y);//AVANÇA Y 
01AC:  BCF    F95.1
01AE:  BSF    F8C.1
....................          delay_ms(300); 
01B0:  MOVLW  02
01B2:  MOVWF  37
01B4:  MOVLW  96
01B6:  MOVWF  39
01B8:  RCALL  0018
01BA:  DECFSZ 37,F
01BC:  BRA    01B4
....................          while(input(sa_y)==0); 
01BE:  BSF    F96.0
01C0:  BTFSS  F84.0
01C2:  BRA    01BE
....................          delay_ms(300); 
01C4:  MOVLW  02
01C6:  MOVWF  37
01C8:  MOVLW  96
01CA:  MOVWF  39
01CC:  RCALL  0018
01CE:  DECFSZ 37,F
01D0:  BRA    01C8
....................          get_ventosa();//PEGA O BLOCO 
01D2:  RCALL  00CE
....................           gx = 2; 
01D4:  MOVLW  02
01D6:  MOVWF  35
....................           gy = 2; 
01D8:  MOVWF  36
....................       }else if(gy==0){//CHECA SE Y DEVE SER RETORNADO 
01DA:  BRA    01F6
01DC:  MOVF   36,F
01DE:  BNZ   01F6
....................          delay_ms(300); 
01E0:  MOVLW  02
01E2:  MOVWF  37
01E4:  MOVLW  96
01E6:  MOVWF  39
01E8:  RCALL  0018
01EA:  DECFSZ 37,F
01EC:  BRA    01E4
....................          get_ventosa();//PEGA O BLOCO 
01EE:  RCALL  00CE
....................           gx = 2; 
01F0:  MOVLW  02
01F2:  MOVWF  35
....................           gy = 2; 
01F4:  MOVWF  36
....................       } 
....................    } 
....................    return 0; 
01F6:  MOVLW  00
01F8:  MOVWF  01
01FA:  GOTO   03C6 (RETURN)
.................... } 
....................  
.................... void reset() { 
....................    delay_ms(300); 
*
0082:  MOVLW  02
0084:  MOVWF  37
0086:  MOVLW  96
0088:  MOVWF  39
008A:  RCALL  0018
008C:  DECFSZ 37,F
008E:  BRA    0086
....................    if(input(sa_x)==1) { 
0090:  BSF    F92.4
0092:  BTFSS  F80.4
0094:  BRA    00AE
....................    b_V(1); 
0096:  MOVLW  01
0098:  MOVWF  37
009A:  RCALL  003E
....................       output_low(x); 
009C:  BCF    F95.0
009E:  BCF    F8C.0
....................       delay_ms(500); 
00A0:  MOVLW  02
00A2:  MOVWF  37
00A4:  MOVLW  FA
00A6:  MOVWF  39
00A8:  RCALL  0018
00AA:  DECFSZ 37,F
00AC:  BRA    00A4
....................    } 
....................    if(input(sa_y)==1) { 
00AE:  BSF    F96.0
00B0:  BTFSS  F84.0
00B2:  BRA    00CC
....................       b_V(1); 
00B4:  MOVLW  01
00B6:  MOVWF  37
00B8:  RCALL  003E
....................       output_low(y); 
00BA:  BCF    F95.1
00BC:  BCF    F8C.1
....................       delay_ms(500); 
00BE:  MOVLW  02
00C0:  MOVWF  37
00C2:  MOVLW  FA
00C4:  MOVWF  39
00C6:  RCALL  0018
00C8:  DECFSZ 37,F
00CA:  BRA    00C2
....................    } 
00CC:  RETURN 0
.................... } 
....................  
.................... int b_V(int v){// parametro q retorna quantidade de vezes executa o codigo 
*
003E:  CLRF   38
....................    int i = 0; 
....................    for(i = 0; i < v; v--) { 
0040:  CLRF   38
0042:  MOVF   37,W
0044:  SUBWF  38,W
0046:  BC    005A
....................       output_high(buzzer); 
0048:  BCF    F94.1
004A:  BSF    F8B.1
....................       delay_ms(20); 
004C:  MOVLW  14
004E:  MOVWF  39
0050:  RCALL  0018
....................       output_low(buzzer); 
0052:  BCF    F94.1
0054:  BCF    F8B.1
0056:  DECF   37,F
0058:  BRA    0042
....................    } 
....................    return 0; 
005A:  MOVLW  00
005C:  MOVWF  01
005E:  RETURN 0
.................... } 
....................  
.................... int b_Q(int q){ 
0060:  CLRF   38
....................    int i = 0; 
....................    for(i = 0; i < q; q--) { 
0062:  CLRF   38
0064:  MOVF   37,W
0066:  SUBWF  38,W
0068:  BC    007C
....................    output_high(buzzer); 
006A:  BCF    F94.1
006C:  BSF    F8B.1
....................    delay_ms(40); 
006E:  MOVLW  28
0070:  MOVWF  39
0072:  RCALL  0018
....................    output_low(buzzer); 
0074:  BCF    F94.1
0076:  BCF    F8B.1
0078:  DECF   37,F
007A:  BRA    0064
....................    } 
....................    return 0; 
007C:  MOVLW  00
007E:  MOVWF  01
0080:  RETURN 0
.................... } 
....................  
.................... int b_C(int c){ 
....................    int i = 0; 
....................    for(i = 0; i < c; c--) { 
....................    output_high(buzzer); 
....................    delay_ms(100); 
....................    output_low(buzzer); 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... void b_S(int s){ 
*
030A:  CLRF   34
....................    int i = 0; 
....................    for(i = 0; i < s; s--) { 
030C:  CLRF   34
030E:  MOVF   33,W
0310:  SUBWF  34,W
0312:  BC    032E
....................    output_high(buzzer); 
0314:  BCF    F94.1
0316:  BSF    F8B.1
....................    delay_ms(1000); 
0318:  MOVLW  04
031A:  MOVWF  35
031C:  MOVLW  FA
031E:  MOVWF  39
0320:  RCALL  0018
0322:  DECFSZ 35,F
0324:  BRA    031C
....................    output_low(buzzer); 
0326:  BCF    F94.1
0328:  BCF    F8B.1
032A:  DECF   33,F
032C:  BRA    030E
....................    } 
032E:  GOTO   03DA (RETURN)
.................... } 
....................  
....................  
.................... void main(){   
*
03DC:  CLRF   FF8
03DE:  BCF    FD0.7
03E0:  BSF    FB8.3
03E2:  MOVLW  08
03E4:  MOVWF  FAF
03E6:  MOVLW  02
03E8:  MOVWF  FB0
03EA:  MOVLW  A6
03EC:  MOVWF  FAC
03EE:  MOVLW  90
03F0:  MOVWF  FAB
03F2:  MOVF   FC1,W
03F4:  ANDLW  C0
03F6:  IORLW  0F
03F8:  MOVWF  FC1
03FA:  MOVLW  07
03FC:  MOVWF  FB4
03FE:  CLRF   04
0400:  CLRF   05
....................    while(true) { 
.................... /* 
.................... # 
.................... ##EXEMPLO DE IDENTIFICAÇÃO 
.................... # 
.................... #USE 0 1 PARA IDENTIFICAR, 2 PARA NEGAR O CHAR 
.................... parametro;  11,00|01,11|10,01|11,10 
.................... tradução;    d+a   c+d   b+c   d+b 
.................... bancada;          A B   |   D C 
....................                   C D   |   B A 
.................... #                   
.................... #    TODO: CODIGO;            
.................... */ 
....................       if(input(start)==1) {          
0402:  BSF    F92.1
0404:  BTFSS  F80.1
0406:  BRA    0432
....................          int arr[16] = {1,1,0,0,0,1,1,1,1,0,0,1,1,1,1,0}; 
0408:  MOVLW  01
040A:  MOVWF  0B
040C:  MOVWF  0C
040E:  CLRF   0D
0410:  CLRF   0E
0412:  CLRF   0F
0414:  MOVWF  10
0416:  MOVWF  11
0418:  MOVWF  12
041A:  MOVWF  13
041C:  CLRF   14
041E:  CLRF   15
0420:  MOVWF  16
0422:  MOVWF  17
0424:  MOVWF  18
0426:  MOVWF  19
0428:  CLRF   1A
....................          process_all(arr); 
042A:  CLRF   2C
042C:  MOVLW  0B
042E:  MOVWF  2B
0430:  RCALL  0332
....................       } 
....................       if(input(stop)==1) { 
0432:  BSF    F92.2
0434:  BTFSS  F80.2
0436:  BRA    0464
....................          int arr[16] = {0,0,1,1,0,1,0,0,2,2,2,2,2,2,2,2}; 
0438:  CLRF   1B
043A:  CLRF   1C
043C:  MOVLW  01
043E:  MOVWF  1D
0440:  MOVWF  1E
0442:  CLRF   1F
0444:  MOVWF  20
0446:  CLRF   21
0448:  CLRF   22
044A:  MOVLW  02
044C:  MOVWF  23
044E:  MOVWF  24
0450:  MOVWF  25
0452:  MOVWF  26
0454:  MOVWF  27
0456:  MOVWF  28
0458:  MOVWF  29
045A:  MOVWF  2A
....................          process_all(arr); 
045C:  CLRF   2C
045E:  MOVLW  1B
0460:  MOVWF  2B
0462:  RCALL  0332
....................       } 
0464:  BRA    0402
....................    } 
.................... } 
0466:  SLEEP 

Configuration Fuses:
   Word  1: CC04   PLL5 CPUDIV1 NOUSBDIV HS FCMEN IESO
   Word  2: 0E38   PUT NOBROWNOUT BORV21 VREGEN NOWDT WDT128
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
